<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spotify Artist Comparison Cards</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
  <style>
    /* Scoped styles for Artist Comparison feature */
    .acc-card {
      background: linear-gradient(145deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      border: 2px solid transparent;
      background-clip: padding-box;
      position: relative;
    }
    .acc-card::before {
      content: '';
      position: absolute;
      inset: -2px;
      background: linear-gradient(145deg, #e94560, #ff6b6b, #ffd93d, #6bcb77);
      border-radius: inherit;
      z-index: -1;
      opacity: 0.8;
    }
    .acc-card:hover::before {
      opacity: 1;
      animation: acc-border-glow 2s linear infinite;
    }
    @keyframes acc-border-glow {
      0%, 100% { filter: hue-rotate(0deg); }
      50% { filter: hue-rotate(30deg); }
    }
    .acc-card-image {
      border: 3px solid rgba(255,255,255,0.2);
      box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    }
    .acc-popularity-bar {
      background: linear-gradient(90deg, #e94560, #ffd93d, #6bcb77);
    }
    .acc-stat-label {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #9ca3af;
    }
    .acc-stat-value {
      font-weight: 700;
      font-size: 1.1rem;
      color: #fff;
    }
    .acc-approximate {
      border-color: #f59e0b !important;
    }
    .acc-approximate::before {
      background: linear-gradient(145deg, #f59e0b, #d97706) !important;
    }
    .acc-tray::-webkit-scrollbar {
      height: 8px;
    }
    .acc-tray::-webkit-scrollbar-track {
      background: #1f2937;
      border-radius: 4px;
    }
    .acc-tray::-webkit-scrollbar-thumb {
      background: #4b5563;
      border-radius: 4px;
    }
    .acc-tray::-webkit-scrollbar-thumb:hover {
      background: #6b7280;
    }
    .acc-skeleton {
      background: linear-gradient(90deg, #374151 25%, #4b5563 50%, #374151 75%);
      background-size: 200% 100%;
      animation: acc-shimmer 1.5s infinite;
    }
    @keyframes acc-shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    .acc-search-result:hover {
      background: rgba(233, 69, 96, 0.1);
    }
    .acc-btn-primary {
      background: linear-gradient(135deg, #e94560, #ff6b6b);
      transition: all 0.2s;
    }
    .acc-btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(233, 69, 96, 0.4);
    }
    .acc-genre-tag {
      background: rgba(107, 203, 119, 0.2);
      color: #6bcb77;
      font-size: 0.65rem;
      padding: 2px 6px;
      border-radius: 9999px;
    }
    .acc-loading-spinner {
      border: 2px solid rgba(255,255,255,0.1);
      border-top-color: #e94560;
      animation: acc-spin 0.8s linear infinite;
    }
    @keyframes acc-spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">
  <!--
    ============================================================
    ARTIST COMPARISON CARDS FEATURE
    ============================================================
    A WWE/trading-card style comparison tool for Spotify artists.
    
    PRODUCTION TOKEN FLOW (Recommended):
    Instead of pasting tokens in the UI, set up a backend proxy:
    
    1. Create a server endpoint (e.g., /api/spotify-token) that:
       - Uses Client Credentials Flow with your client_id + client_secret
       - POST to https://accounts.spotify.com/api/token
       - Returns { access_token, expires_in }
    
    2. Create proxy endpoints for Spotify API calls:
       - /api/spotify/search?q=...
       - /api/spotify/artist/:id
       - /api/spotify/artist/:id/albums
       - /api/spotify/album/:id/tracks
    
    3. Replace getToken() to fetch from your backend
    4. Replace spotifyFetch() to use your proxy endpoints
    
    This keeps secrets server-side and handles token refresh automatically.
    ============================================================
  -->

  <div id="acc-app" class="max-w-7xl mx-auto px-4 py-8">
    <!-- Header -->
    <header class="text-center mb-8">
      <h1 class="text-4xl font-bold bg-gradient-to-r from-pink-500 via-red-500 to-yellow-500 bg-clip-text text-transparent mb-2">
        üéµ Artist Comparison Cards
      </h1>
      <p class="text-gray-400">Compare your favorite Spotify artists side-by-side</p>
    </header>

    <!-- Error Banner -->
    <div id="acc-error-banner" class="hidden bg-red-900/50 border border-red-500 rounded-lg p-4 mb-6" role="alert">
      <div class="flex items-start gap-3">
        <span class="text-red-400 text-xl">‚ö†Ô∏è</span>
        <div class="flex-1">
          <h3 id="acc-error-title" class="font-semibold text-red-300">Error</h3>
          <p id="acc-error-message" class="text-red-200 text-sm mt-1"></p>
          <button id="acc-error-dismiss" class="mt-2 text-xs text-red-300 hover:text-white underline">Dismiss</button>
        </div>
      </div>
    </div>

    <!-- Token Input Section -->
    <div class="bg-gray-800 rounded-lg p-4 mb-6">
      <label for="acc-token-input" class="block text-sm font-medium text-gray-300 mb-2">
        üîë Spotify Access Token <span class="text-gray-500">(Development Only)</span>
      </label>
      <div class="flex gap-2">
        <input 
          type="password" 
          id="acc-token-input" 
          class="flex-1 bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-transparent"
          placeholder="Paste Bearer token or just the token string..."
          aria-describedby="acc-token-help"
        >
        <button 
          id="acc-token-save" 
          class="acc-btn-primary px-4 py-2 rounded-lg font-medium"
          aria-label="Save token"
        >
          Save
        </button>
      </div>
      <p id="acc-token-help" class="text-xs text-gray-500 mt-2">
        Get a token from <a href="https://developer.spotify.com/console/" target="_blank" rel="noopener" class="text-pink-400 hover:underline">Spotify Developer Console</a>. 
        For production, use a backend proxy with Client Credentials flow.
      </p>
      <p id="acc-token-status" class="text-xs mt-1 hidden"></p>
    </div>

    <!-- Search Section -->
    <div class="bg-gray-800 rounded-lg p-4 mb-6">
      <label for="acc-search-input" class="block text-sm font-medium text-gray-300 mb-2">
        üîç Search Artists
      </label>
      <div class="flex gap-2 mb-4">
        <input 
          type="text" 
          id="acc-search-input" 
          class="flex-1 bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-pink-500 focus:border-transparent"
          placeholder="Enter artist name..."
          aria-label="Search for artists"
        >
        <button 
          id="acc-search-btn" 
          class="acc-btn-primary px-6 py-2 rounded-lg font-medium flex items-center gap-2"
          aria-label="Search"
        >
          <span id="acc-search-icon">üîç</span>
          <span class="hidden sm:inline">Search</span>
        </button>
      </div>
      
      <!-- Search Results -->
      <div id="acc-search-results" class="hidden">
        <h3 class="text-sm font-medium text-gray-400 mb-2">Search Results</h3>
        <div id="acc-results-list" class="space-y-2 max-h-64 overflow-y-auto" role="list" aria-label="Search results">
        </div>
      </div>
    </div>

    <!-- Controls -->
    <div class="flex flex-wrap items-center gap-4 mb-6">
      <div class="flex items-center gap-2">
        <label for="acc-sort-select" class="text-sm text-gray-400">Sort by:</label>
        <select 
          id="acc-sort-select" 
          class="bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-pink-500"
        >
          <option value="followers">Followers</option>
          <option value="popularity">Popularity</option>
          <option value="albums">Albums</option>
          <option value="songs">Songs</option>
          <option value="ratio">Songs/Album</option>
        </select>
      </div>
      <button 
        id="acc-sort-btn" 
        class="bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded-lg font-medium transition-colors"
      >
        ‚ÜïÔ∏è Sort
      </button>
      <button 
        id="acc-clear-btn" 
        class="bg-gray-700 hover:bg-red-600 px-4 py-2 rounded-lg font-medium transition-colors"
      >
        üóëÔ∏è Clear All
      </button>
      <span id="acc-card-count" class="text-sm text-gray-500 ml-auto"></span>
    </div>

    <!-- Comparison Tray -->
    <div 
      id="acc-tray" 
      class="acc-tray flex gap-4 overflow-x-auto pb-4 min-h-[400px]"
      role="region"
      aria-label="Artist comparison cards"
    >
      <div id="acc-empty-state" class="flex-1 flex flex-col items-center justify-center text-gray-500 py-12">
        <span class="text-6xl mb-4">üé§</span>
        <p class="text-lg">No artists added yet</p>
        <p class="text-sm">Search and add artists to compare them</p>
      </div>
    </div>
  </div>

  <script>
    /**
     * ARTIST COMPARISON CARDS - Spotify Integration
     * 
     * This module provides a trading-card style comparison UI for Spotify artists.
     * 
     * SECURITY NOTES:
     * - Never commit real tokens to source control
     * - For production, implement a backend proxy (see comments at top of file)
     * - Tokens from the Developer Console expire after 1 hour
     * 
     * RATE LIMITS:
     * - Spotify allows ~180 requests per minute for most endpoints
     * - This implementation uses concurrency limiting (max 3 parallel requests)
     * - If you hit 429, wait for Retry-After header duration
     */

    (function() {
      'use strict';

      // ============================================================
      // CONFIGURATION
      // ============================================================
      const CONFIG = {
        SPOTIFY_API_BASE: 'https://api.spotify.com/v1',
        MAX_CONCURRENT_REQUESTS: 3,
        MAX_ALBUMS_FULL_FETCH: 200, // Beyond this, use summary mode
        SUMMARY_MODE_ALBUM_LIMIT: 50, // Albums to fetch in summary mode
        STORAGE_KEY_ARTISTS: 'acc_artist_ids',
        STORAGE_KEY_TOKEN: 'acc_spotify_token',
        STORAGE_KEY_SCROLL: 'acc_scroll_position'
      };

      // ============================================================
      // STATE
      // ============================================================
      const state = {
        token: null,
        artistIds: [],
        artistCache: new Map(), // In-memory cache for computed stats
        isSearching: false,
        pendingFetches: new Map() // Track ongoing fetches
      };

      // ============================================================
      // DOM ELEMENTS
      // ============================================================
      const elements = {
        tokenInput: document.getElementById('acc-token-input'),
        tokenSave: document.getElementById('acc-token-save'),
        tokenStatus: document.getElementById('acc-token-status'),
        searchInput: document.getElementById('acc-search-input'),
        searchBtn: document.getElementById('acc-search-btn'),
        searchIcon: document.getElementById('acc-search-icon'),
        searchResults: document.getElementById('acc-search-results'),
        resultsList: document.getElementById('acc-results-list'),
        sortSelect: document.getElementById('acc-sort-select'),
        sortBtn: document.getElementById('acc-sort-btn'),
        clearBtn: document.getElementById('acc-clear-btn'),
        cardCount: document.getElementById('acc-card-count'),
        tray: document.getElementById('acc-tray'),
        emptyState: document.getElementById('acc-empty-state'),
        errorBanner: document.getElementById('acc-error-banner'),
        errorTitle: document.getElementById('acc-error-title'),
        errorMessage: document.getElementById('acc-error-message'),
        errorDismiss: document.getElementById('acc-error-dismiss')
      };

      // ============================================================
      // UTILITY FUNCTIONS
      // ============================================================

      /**
       * Format large numbers with K/M suffix
       */
      function formatNumber(num) {
        if (num >= 1000000) {
          return (num / 1000000).toFixed(1) + 'M';
        }
        if (num >= 1000) {
          return (num / 1000).toFixed(1) + 'K';
        }
        return num.toString();
      }

      /**
       * Debounce function to limit rapid calls
       */
      function debounce(fn, delay) {
        let timeoutId;
        return (...args) => {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => fn(...args), delay);
        };
      }

      /**
       * Concurrency-limited Promise.all
       */
      async function promiseAllLimit(tasks, limit) {
        const results = [];
        const executing = new Set();
        
        for (const task of tasks) {
          const promise = Promise.resolve().then(() => task());
          results.push(promise);
          executing.add(promise);
          
          const cleanup = () => executing.delete(promise);
          promise.then(cleanup, cleanup);
          
          if (executing.size >= limit) {
            await Promise.race(executing);
          }
        }
        
        return Promise.allSettled(results);
      }

      // ============================================================
      // ERROR HANDLING
      // ============================================================

      function showError(title, message) {
        elements.errorTitle.textContent = title;
        elements.errorMessage.innerHTML = message;
        elements.errorBanner.classList.remove('hidden');
        elements.errorBanner.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }

      function hideError() {
        elements.errorBanner.classList.add('hidden');
      }

      // ============================================================
      // TOKEN MANAGEMENT
      // ============================================================

      /**
       * Get the current token
       * 
       * PRODUCTION NOTE: Replace this with a fetch to your backend:
       * async function getToken() {
       *   const res = await fetch('/api/spotify-token');
       *   const { access_token } = await res.json();
       *   return access_token;
       * }
       */
      function getToken() {
        return state.token;
      }

      function saveToken(token) {
        // Clean up token - remove "Bearer " prefix if included
        const cleanToken = token.replace(/^Bearer\s+/i, '').trim();
        state.token = cleanToken;
        localStorage.setItem(CONFIG.STORAGE_KEY_TOKEN, cleanToken);
        updateTokenStatus(true);
        hideError();
      }

      function loadToken() {
        const stored = localStorage.getItem(CONFIG.STORAGE_KEY_TOKEN);
        if (stored) {
          state.token = stored;
          elements.tokenInput.value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
          updateTokenStatus(true);
        }
      }

      function updateTokenStatus(valid) {
        elements.tokenStatus.classList.remove('hidden');
        if (valid) {
          elements.tokenStatus.textContent = '‚úì Token saved';
          elements.tokenStatus.className = 'text-xs mt-1 text-green-400';
        } else {
          elements.tokenStatus.textContent = '‚úó Invalid or expired token';
          elements.tokenStatus.className = 'text-xs mt-1 text-red-400';
        }
      }

      // ============================================================
      // SPOTIFY API
      // ============================================================

      /**
       * Make authenticated request to Spotify API
       * 
       * PRODUCTION NOTE: Replace with proxy calls:
       * async function spotifyFetch(endpoint) {
       *   const res = await fetch(`/api/spotify${endpoint}`);
       *   return res.json();
       * }
       */
      async function spotifyFetch(endpoint, retries = 2) {
        const token = getToken();
        if (!token) {
          throw new Error('NO_TOKEN');
        }

        const url = endpoint.startsWith('http') 
          ? endpoint 
          : `${CONFIG.SPOTIFY_API_BASE}${endpoint}`;

        const response = await fetch(url, {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        if (response.status === 401) {
          updateTokenStatus(false);
          throw new Error('TOKEN_EXPIRED');
        }

        if (response.status === 429) {
          const retryAfter = response.headers.get('Retry-After') || 30;
          throw new Error(`RATE_LIMITED:${retryAfter}`);
        }

        if (!response.ok) {
          throw new Error(`API_ERROR:${response.status}`);
        }

        return response.json();
      }

      /**
       * Search for artists
       */
      async function searchArtists(query) {
        const data = await spotifyFetch(`/search?q=${encodeURIComponent(query)}&type=artist&limit=10`);
        return data.artists.items;
      }

      /**
       * Get artist details
       */
      async function getArtist(artistId) {
        return spotifyFetch(`/artists/${artistId}`);
      }

      /**
       * Get all albums for an artist with pagination and deduplication
       */
      async function getArtistAlbums(artistId, summaryMode = false) {
        const albums = [];
        const seen = new Set(); // Dedupe by name+release_date
        let url = `/artists/${artistId}/albums?include_groups=album,single&limit=50`;
        let totalFetched = 0;
        const limit = summaryMode ? CONFIG.SUMMARY_MODE_ALBUM_LIMIT : Infinity;

        while (url && totalFetched < limit) {
          const data = await spotifyFetch(url);
          
          for (const album of data.items) {
            const key = `${album.name.toLowerCase()}|${album.release_date}`;
            if (!seen.has(key)) {
              seen.add(key);
              albums.push(album);
            }
          }
          
          totalFetched += data.items.length;
          url = data.next;
          
          if (summaryMode && albums.length >= CONFIG.SUMMARY_MODE_ALBUM_LIMIT) {
            break;
          }
        }

        return {
          albums,
          isComplete: !url || !summaryMode,
          totalAvailable: totalFetched
        };
      }

      /**
       * Get tracks for an album
       */
      async function getAlbumTracks(albumId) {
        const tracks = [];
        let url = `/albums/${albumId}/tracks?limit=50`;

        while (url) {
          const data = await spotifyFetch(url);
          tracks.push(...data.items);
          url = data.next;
        }

        return tracks;
      }

      /**
       * Fetch complete artist stats with progressive updates
       */
      async function fetchArtistStats(artistId, onProgress) {
        // Check cache first
        if (state.artistCache.has(artistId)) {
          return state.artistCache.get(artistId);
        }

        const stats = {
          id: artistId,
          name: '',
          image: '',
          followers: 0,
          popularity: 0,
          genres: [],
          albums: 0,
          songs: 0,
          ratio: 0,
          isApproximate: false,
          isLoading: true,
          loadingStage: 'artist',
          error: null
        };

        try {
          // Fetch basic artist info
          const artist = await getArtist(artistId);
          stats.name = artist.name;
          stats.image = artist.images[0]?.url || '';
          stats.followers = artist.followers.total;
          stats.popularity = artist.popularity;
          stats.genres = artist.genres.slice(0, 3);
          onProgress?.({ ...stats });

          // Check album count to determine mode
          stats.loadingStage = 'albums';
          onProgress?.({ ...stats });

          const { albums, isComplete } = await getArtistAlbums(
            artistId, 
            false // Start with full fetch attempt
          );

          stats.albums = albums.length;
          stats.isApproximate = !isComplete;
          onProgress?.({ ...stats });

          // Determine if we need summary mode
          const useSummaryMode = albums.length > CONFIG.MAX_ALBUMS_FULL_FETCH;
          const albumsToProcess = useSummaryMode 
            ? albums.slice(0, CONFIG.SUMMARY_MODE_ALBUM_LIMIT)
            : albums;

          if (useSummaryMode) {
            stats.isApproximate = true;
          }

          // Fetch tracks with concurrency limit
          stats.loadingStage = 'tracks';
          const uniqueTracks = new Set();
          let processedAlbums = 0;

          const trackTasks = albumsToProcess.map(album => async () => {
            try {
              const tracks = await getAlbumTracks(album.id);
              tracks.forEach(t => uniqueTracks.add(t.id));
              processedAlbums++;
              stats.songs = uniqueTracks.size;
              stats.ratio = stats.albums > 0 
                ? (stats.songs / stats.albums).toFixed(2) 
                : 0;
              stats.loadingProgress = Math.round((processedAlbums / albumsToProcess.length) * 100);
              onProgress?.({ ...stats });
            } catch (err) {
              console.warn(`Failed to fetch tracks for album ${album.id}:`, err);
              // Continue with partial data
            }
          });

          await promiseAllLimit(trackTasks, CONFIG.MAX_CONCURRENT_REQUESTS);

          stats.songs = uniqueTracks.size;
          stats.ratio = stats.albums > 0 
            ? parseFloat((stats.songs / stats.albums).toFixed(2))
            : 0;
          stats.isLoading = false;
          stats.loadingStage = 'complete';

          // Cache the result
          state.artistCache.set(artistId, stats);

          return stats;

        } catch (err) {
          stats.isLoading = false;
          stats.error = err.message;
          
          if (err.message === 'NO_TOKEN') {
            showError('No Token', 'Please enter a valid Spotify access token to use this feature.');
          } else if (err.message === 'TOKEN_EXPIRED') {
            showError('Token Expired', 'Your Spotify token has expired. Please get a new one from the <a href="https://developer.spotify.com/console/" target="_blank" class="underline">Developer Console</a>.');
          } else if (err.message.startsWith('RATE_LIMITED')) {
            const seconds = err.message.split(':')[1];
            showError('Rate Limited', `Spotify API rate limit reached. Please wait ${seconds} seconds before trying again.`);
          } else {
            stats.error = 'partial';
            stats.isApproximate = true;
          }

          return stats;
        }
      }

      // ============================================================
      // UI RENDERING
      // ============================================================

      function renderSearchResults(artists) {
        if (artists.length === 0) {
          elements.resultsList.innerHTML = `
            <div class="text-center text-gray-500 py-4">No artists found</div>
          `;
          elements.searchResults.classList.remove('hidden');
          return;
        }

        elements.resultsList.innerHTML = artists.map(artist => `
          <div class="acc-search-result flex items-center gap-3 p-2 rounded-lg cursor-pointer transition-colors" 
               role="listitem"
               tabindex="0"
               data-artist-id="${artist.id}"
               data-artist-name="${artist.name}">
            <img 
              src="${artist.images[2]?.url || artist.images[0]?.url || 'data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%23374151%22 width=%22100%22 height=%22100%22/><text x=%2250%22 y=%2255%22 text-anchor=%22middle%22 fill=%22%239ca3af%22 font-size=%2240%22>üé§</text></svg>'}" 
              alt="${artist.name}"
              class="w-12 h-12 rounded-full object-cover bg-gray-700"
            >
            <div class="flex-1 min-w-0">
              <div class="font-medium truncate">${artist.name}</div>
              <div class="text-xs text-gray-400">${formatNumber(artist.followers.total)} followers</div>
              <div class="flex flex-wrap gap-1 mt-1">
                ${artist.genres.slice(0, 2).map(g => `<span class="acc-genre-tag">${g}</span>`).join('')}
              </div>
            </div>
            <button 
              class="acc-btn-primary px-3 py-1 rounded-lg text-sm font-medium"
              aria-label="Add ${artist.name} to comparison"
              data-add-artist="${artist.id}"
            >
              + Add
            </button>
          </div>
        `).join('');

        elements.searchResults.classList.remove('hidden');
      }

      function renderCard(stats) {
        const existingCard = document.querySelector(`[data-card-id="${stats.id}"]`);
        
        const cardHtml = `
          <div 
            class="acc-card ${stats.isApproximate ? 'acc-approximate' : ''} flex-shrink-0 w-72 rounded-xl p-4 relative"
            data-card-id="${stats.id}"
            role="article"
            aria-label="Artist card for ${stats.name}"
          >
            ${stats.isApproximate ? `
              <div class="absolute top-2 right-2 bg-amber-500/20 text-amber-400 text-xs px-2 py-0.5 rounded-full" title="Some data is approximate">
                ‚âà Approx
              </div>
            ` : ''}
            
            <button 
              class="absolute top-2 ${stats.isApproximate ? 'right-20' : 'right-2'} text-gray-400 hover:text-red-400 transition-colors p-1"
              aria-label="Remove ${stats.name}"
              data-remove-artist="${stats.id}"
            >
              ‚úï
            </button>

            <!-- Artist Image -->
            <div class="flex justify-center mb-4">
              ${stats.image ? `
                <img 
                  src="${stats.image}" 
                  alt="${stats.name}"
                  class="acc-card-image w-28 h-28 rounded-full object-cover"
                >
              ` : `
                <div class="acc-card-image w-28 h-28 rounded-full bg-gray-700 flex items-center justify-center text-4xl">
                  üé§
                </div>
              `}
            </div>

            <!-- Artist Name -->
            <h3 class="text-xl font-bold text-center mb-4 truncate" title="${stats.name}">
              ${stats.name || 'Loading...'}
            </h3>

            <!-- Stats Grid -->
            <div class="grid grid-cols-2 gap-3 mb-4">
              <div class="text-center">
                <div class="acc-stat-label">Followers</div>
                <div class="acc-stat-value">${stats.isLoading && stats.loadingStage === 'artist' ? '...' : formatNumber(stats.followers)}</div>
              </div>
              <div class="text-center">
                <div class="acc-stat-label">Albums</div>
                <div class="acc-stat-value">
                  ${stats.isLoading && ['artist', 'albums'].includes(stats.loadingStage) 
                    ? '<span class="acc-loading-spinner inline-block w-4 h-4 rounded-full"></span>' 
                    : stats.albums}
                </div>
              </div>
              <div class="text-center">
                <div class="acc-stat-label">Songs</div>
                <div class="acc-stat-value">
                  ${stats.isLoading && stats.loadingStage === 'tracks' 
                    ? `<span class="text-sm">${stats.songs || 0}</span><span class="text-xs text-gray-400 ml-1">${stats.loadingProgress || 0}%</span>` 
                    : stats.songs}
                </div>
              </div>
              <div class="text-center">
                <div class="acc-stat-label">Songs/Album</div>
                <div class="acc-stat-value">${stats.ratio || '-'}</div>
              </div>
            </div>

            <!-- Genres -->
            <div class="flex flex-wrap justify-center gap-1 mb-4 min-h-[24px]">
              ${stats.genres.map(g => `<span class="acc-genre-tag">${g}</span>`).join('') || '<span class="text-gray-500 text-xs">No genres</span>'}
            </div>

            <!-- Popularity -->
            <div class="mt-auto">
              <div class="flex justify-between items-center mb-1">
                <span class="acc-stat-label">Popularity</span>
                <span class="font-bold ${stats.popularity >= 70 ? 'text-green-400' : stats.popularity >= 40 ? 'text-yellow-400' : 'text-red-400'}">
                  ${stats.popularity}
                </span>
              </div>
              <div class="h-2 bg-gray-700 rounded-full overflow-hidden">
                <div 
                  class="acc-popularity-bar h-full rounded-full transition-all duration-500"
                  style="width: ${stats.popularity}%"
                ></div>
              </div>
            </div>

            ${stats.error === 'partial' ? `
              <button 
                class="w-full mt-3 text-xs text-amber-400 hover:text-amber-300 underline"
                data-retry-artist="${stats.id}"
              >
                Retry loading full data
              </button>
            ` : ''}
          </div>
        `;

        if (existingCard) {
          existingCard.outerHTML = cardHtml;
        } else {
          elements.emptyState.classList.add('hidden');
          elements.tray.insertAdjacentHTML('beforeend', cardHtml);
        }

        updateCardCount();
      }

      function renderSkeletonCard(artistId) {
        const html = `
          <div 
            class="acc-card flex-shrink-0 w-72 rounded-xl p-4"
            data-card-id="${artistId}"
          >
            <div class="flex justify-center mb-4">
              <div class="acc-skeleton w-28 h-28 rounded-full"></div>
            </div>
            <div class="acc-skeleton h-6 w-3/4 mx-auto rounded mb-4"></div>
            <div class="grid grid-cols-2 gap-3 mb-4">
              <div class="acc-skeleton h-12 rounded"></div>
              <div class="acc-skeleton h-12 rounded"></div>
              <div class="acc-skeleton h-12 rounded"></div>
              <div class="acc-skeleton h-12 rounded"></div>
            </div>
            <div class="acc-skeleton h-4 w-1/2 mx-auto rounded mb-4"></div>
            <div class="acc-skeleton h-6 rounded"></div>
          </div>
        `;
        elements.emptyState.classList.add('hidden');
        elements.tray.insertAdjacentHTML('beforeend', html);
      }

      function removeCard(artistId) {
        const card = document.querySelector(`[data-card-id="${artistId}"]`);
        if (card) {
          card.remove();
        }
        state.artistIds = state.artistIds.filter(id => id !== artistId);
        saveArtistIds();
        updateCardCount();

        if (state.artistIds.length === 0) {
          elements.emptyState.classList.remove('hidden');
        }
      }

      function updateCardCount() {
        const count = state.artistIds.length;
        elements.cardCount.textContent = count > 0 
          ? `${count} artist${count !== 1 ? 's' : ''} in tray` 
          : '';
      }

      function sortCards() {
        const sortBy = elements.sortSelect.value;
        const cards = Array.from(elements.tray.querySelectorAll('.acc-card'));
        
        cards.sort((a, b) => {
          const aId = a.dataset.cardId;
          const bId = b.dataset.cardId;
          const aStats = state.artistCache.get(aId) || {};
          const bStats = state.artistCache.get(bId) || {};

          switch (sortBy) {
            case 'followers':
              return (bStats.followers || 0) - (aStats.followers || 0);
            case 'popularity':
              return (bStats.popularity || 0) - (aStats.popularity || 0);
            case 'albums':
              return (bStats.albums || 0) - (aStats.albums || 0);
            case 'songs':
              return (bStats.songs || 0) - (aStats.songs || 0);
            case 'ratio':
              return (bStats.ratio || 0) - (aStats.ratio || 0);
            default:
              return 0;
          }
        });

        // Reorder DOM
        cards.forEach(card => elements.tray.appendChild(card));
        
        // Update artistIds order
        state.artistIds = cards.map(c => c.dataset.cardId);
        saveArtistIds();
      }

      function clearAllCards() {
        if (!confirm('Remove all artists from the comparison tray?')) return;
        
        elements.tray.querySelectorAll('.acc-card').forEach(card => card.remove());
        state.artistIds = [];
        state.artistCache.clear();
        saveArtistIds();
        updateCardCount();
        elements.emptyState.classList.remove('hidden');
      }

      // ============================================================
      // PERSISTENCE
      // ============================================================

      function saveArtistIds() {
        localStorage.setItem(CONFIG.STORAGE_KEY_ARTISTS, JSON.stringify(state.artistIds));
      }

      function loadArtistIds() {
        try {
          const stored = localStorage.getItem(CONFIG.STORAGE_KEY_ARTISTS);
          return stored ? JSON.parse(stored) : [];
        } catch {
          return [];
        }
      }

      function saveScrollPosition() {
        localStorage.setItem(CONFIG.STORAGE_KEY_SCROLL, elements.tray.scrollLeft.toString());
      }

      function restoreScrollPosition() {
        const pos = localStorage.getItem(CONFIG.STORAGE_KEY_SCROLL);
        if (pos) {
          elements.tray.scrollLeft = parseInt(pos, 10);
        }
      }

      // ============================================================
      // EVENT HANDLERS
      // ============================================================

      async function handleSearch() {
        const query = elements.searchInput.value.trim();
        if (!query || state.isSearching) return;

        if (!getToken()) {
          showError('No Token', 'Please enter a Spotify access token first.');
          elements.tokenInput.focus();
          return;
        }

        state.isSearching = true;
        elements.searchIcon.textContent = '‚è≥';
        elements.searchBtn.disabled = true;

        try {
          const artists = await searchArtists(query);
          renderSearchResults(artists);
        } catch (err) {
          if (err.message === 'NO_TOKEN') {
            showError('No Token', 'Please enter a valid Spotify access token.');
          } else if (err.message === 'TOKEN_EXPIRED') {
            showError('Token Expired', 'Your token has expired. Please get a new one.');
          } else {
            showError('Search Failed', 'Could not search artists. Please try again.');
          }
          elements.searchResults.classList.add('hidden');
        } finally {
          state.isSearching = false;
          elements.searchIcon.textContent = 'üîç';
          elements.searchBtn.disabled = false;
        }
      }

      async function addArtist(artistId) {
        // Prevent duplicates
        if (state.artistIds.includes(artistId)) {
          const card = document.querySelector(`[data-card-id="${artistId}"]`);
          card?.scrollIntoView({ behavior: 'smooth', inline: 'center' });
          return;
        }

        state.artistIds.push(artistId);
        saveArtistIds();
        
        // Show skeleton immediately
        renderSkeletonCard(artistId);

        // Fetch and update progressively
        const stats = await fetchArtistStats(artistId, (progress) => {
          renderCard(progress);
        });

        renderCard(stats);
      }

      async function retryArtist(artistId) {
        // Remove from cache to force refetch
        state.artistCache.delete(artistId);
        
        const stats = await fetchArtistStats(artistId, (progress) => {
          renderCard(progress);
        });
        
        renderCard(stats);
      }

      // ============================================================
      // INITIALIZATION
      // ============================================================

      function setupEventListeners() {
        // Token
        elements.tokenSave.addEventListener('click', () => {
          const token = elements.tokenInput.value.trim();
          if (token && token !== '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢') {
            saveToken(token);
            elements.tokenInput.value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
          }
        });

        elements.tokenInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            elements.tokenSave.click();
          }
        });

        // Search
        elements.searchBtn.addEventListener('click', handleSearch);
        elements.searchInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            handleSearch();
          }
        });

        // Search results (delegated)
        elements.resultsList.addEventListener('click', (e) => {
          const addBtn = e.target.closest('[data-add-artist]');
          if (addBtn) {
            const artistId = addBtn.dataset.addArtist;
            addArtist(artistId);
            elements.searchResults.classList.add('hidden');
            elements.searchInput.value = '';
          }
        });

        elements.resultsList.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            const result = e.target.closest('.acc-search-result');
            if (result) {
              const artistId = result.dataset.artistId;
              addArtist(artistId);
              elements.searchResults.classList.add('hidden');
              elements.searchInput.value = '';
            }
          }
        });

        // Tray events (delegated)
        elements.tray.addEventListener('click', (e) => {
          const removeBtn = e.target.closest('[data-remove-artist]');
          if (removeBtn) {
            removeCard(removeBtn.dataset.removeArtist);
          }

          const retryBtn = e.target.closest('[data-retry-artist]');
          if (retryBtn) {
            retryArtist(retryBtn.dataset.retryArtist);
          }
        });

        // Sort & Clear
        elements.sortBtn.addEventListener('click', sortCards);
        elements.clearBtn.addEventListener('click', clearAllCards);

        // Error banner
        elements.errorDismiss.addEventListener('click', hideError);

        // Save scroll position
        elements.tray.addEventListener('scroll', debounce(saveScrollPosition, 200));

        // Save scroll on unload
        window.addEventListener('beforeunload', saveScrollPosition);
      }

      async function restoreState() {
        loadToken();
        
        const artistIds = loadArtistIds();
        if (artistIds.length === 0) return;

        elements.emptyState.classList.add('hidden');

        // Restore cards progressively
        for (const artistId of artistIds) {
          state.artistIds.push(artistId);
          renderSkeletonCard(artistId);
        }

        updateCardCount();

        // Fetch data with some delay between to avoid rate limits
        for (const artistId of artistIds) {
          if (getToken()) {
            const stats = await fetchArtistStats(artistId, (progress) => {
              renderCard(progress);
            });
            renderCard(stats);
          } else {
            // Show placeholder if no token
            renderCard({
              id: artistId,
              name: 'Token Required',
              image: '',
              followers: 0,
              popularity: 0,
              genres: [],
              albums: 0,
              songs: 0,
              ratio: 0,
              isLoading: false,
              error: 'no_token'
            });
          }
        }

        // Restore scroll position after cards are rendered
        setTimeout(restoreScrollPosition, 100);
      }

      function init() {
        console.log('%cüéµ Artist Comparison Cards', 'font-size: 20px; font-weight: bold; color: #e94560;');
        console.log('%c‚ö†Ô∏è Security Note: Never commit real tokens. Use a backend proxy in production.', 'color: #f59e0b;');
        console.log('%cüìä Rate Limits: Spotify allows ~180 requests/min. This tool limits concurrency to avoid hitting limits.', 'color: #6bcb77;');

        setupEventListeners();
        restoreState();
      }

      // Start when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }

      /*
       * ============================================================
       * MANUAL TESTING CHECKLIST
       * ============================================================
       * 
       * 1. Token Validation:
       *    - Clear localStorage and refresh
       *    - Try searching without a token ‚Üí verify error banner appears
       *    - Paste an invalid token ‚Üí search ‚Üí verify "Token Expired" error
       *    - Paste a valid token ‚Üí verify "Token saved" appears
       * 
       * 2. Search & Add:
       *    - Search for "Adele" ‚Üí verify results appear with images and followers
       *    - Click "+ Add" ‚Üí verify card appears with skeleton then loads data
       *    - Search for "Taylor Swift" and add ‚Üí verify second card appears
       *    - Try adding the same artist twice ‚Üí verify no duplicate, scrolls to existing
       * 
       * 3. Card Data:
       *    - Verify followers are formatted (e.g., "85.2M" not "85200000")
       *    - Verify albums, songs, and ratio load progressively
       *    - Verify popularity bar matches the number
       *    - Verify up to 3 genres are shown
       * 
       * 4. Sorting:
       *    - Add 3+ artists
       *    - Select "Popularity" from dropdown and click Sort ‚Üí verify order changes
       *    - Try other sort options ‚Üí verify correct ordering
       * 
       * 5. Persistence:
       *    - Add some artists, then refresh the page
       *    - Verify artists are restored and data reloads
       *    - Scroll the tray, refresh ‚Üí verify scroll position is restored
       * 
       * 6. Remove & Clear:
       *    - Click ‚úï on a card ‚Üí verify it's removed
       *    - Click "Clear All" ‚Üí confirm ‚Üí verify all cards removed
       *    - Refresh ‚Üí verify tray is empty
       * 
       * 7. Large Discography (Summary Mode):
       *    - Search for an artist with many albums (e.g., "Various Artists" or "Elvis")
       *    - Verify "‚âà Approx" badge appears if summary mode is used
       *    - Verify data still loads without freezing the UI
       * 
       * 8. Error Handling:
       *    - Disconnect internet mid-fetch ‚Üí verify partial state shown
       *    - Verify "Retry" button appears for failed cards
       *    - Wait for token to expire ‚Üí verify clear error message
       * 
       * 9. Accessibility:
       *    - Tab through controls ‚Üí verify focus is visible
       *    - Press Enter on search input ‚Üí verify search triggers
       *    - Use keyboard to navigate search results
       * 
       * 10. Responsive:
       *     - Resize to mobile width ‚Üí verify tray scrolls horizontally
       *     - Verify cards maintain readable size
       *     - Verify controls wrap appropriately
       * 
       * ============================================================
       */

    })();
  </script>
</body>
</html>
